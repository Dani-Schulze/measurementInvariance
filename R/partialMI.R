############ # Thu May 27 15:05:41 2021 ------------------------------
###
#' @title partialMI
#'
#' @description Estimate a single partial MI model with a given anchor item set (aka cluster).
#'
#' @param res_clusterItems Object generated by \code{\link{clusterItems}}.
#' @param anchorClusters # String indicating which cluster to use for which factor,
#' e.g. \code{"Factor1 1 Factor2 1"}
#' for indicating to use cluster 1 of both item clusterings
#' @param silent Do not print summary output? Defaults to \code{FALSE}.
#'
#' @return A single (multidimensional) model as defined by the \code{model}
#' argument in \code{testMI}. Results are directly printed to the console but can
#' be further inspected by lavaan's or mirt's functions.
#'
#' @usage res <- partialMI(res_clusterItems,
#'                         "Factor1 1 Factor2 1")
#'
#' @export


partialMI <- function(res_clusterItems,
                      anchorClusters,
                      silent = FALSE) {
  res <- res_clusterItems

  ## switch for getting desired clusters per factor. A rather badly written section.
  clusters <- list()  # internal representation
  lvsPlaces <- lapply(res$lvs, FUN = regexpr, anchorClusters) # parse input string # X added whitespace around =
  lvsPlaces <- append(lvsPlaces, nchar(anchorClusters) + 1) # add final stop in order to make loop below work
  if (any(lvsPlaces < 0) &&
      nchar(anchorClusters) > (sum(nchar(res$lvs)) + 2*length(res$lvs))) {
    stop("Error while reading anchorClusters. Couldn't retrieve factor names.", call. = FALSE)   # check for misspelled factor names
  }
  for (lv in res$lvs) {
    clusters[[lv]] <- as.numeric(substring(anchorClusters, lvsPlaces[[which(
      res$lvs %in% lv)]] + attr(lvsPlaces[[which(res$lvs %in% lv)]], "match.length"),
      lvsPlaces[[which(res$lvs %in% lv) + 1]] - 1))
  }

  if (any(lapply(clusters, FUN = length) == 0)) {
    stop("Error while reading cluster. Check your statements.")
  }
  # lavaan
  if (res$settings$dichModel == "factor") {
    partialItems <- NULL
    for (lv in res$lvs) {
      currNonAnchor <- which(res[[lv]]$itemClustering$finalClustering != clusters[[lv]])
      partialItems <- append(partialItems,
                             paste0(lv, "=~", res$items[[lv]][currNonAnchor]))
      if (res$settings$MI[[lv]] == "strong") {
        partialItems <- append(partialItems,
                               paste0(res$items[[lv]][currNonAnchor], "~ 1"))
      }
    }

    int <- "intercepts"
    if (res$settings$dich) {
      int <- "thresholds"
    }
    catItems <- NULL
    if (res$settings$dich) {
      catItems <- unlist(res$items)
    }

    output <- cfa(res$model,
                  data = res$data,
                  estimator = res$settings$estim,
                  group = res$group,
                  meanstructure = TRUE,
                  std.lv = TRUE,
                  ordered = catItems,
                  group.equal = c("loadings", int),
                  group.partial = partialItems,
                  missing = res$settings$missings)
  } else {
    # mirt
    if (length(res$lvs) > 2) {
      print("This will take a while..." )
    }
    dat0 <- res$data[, -which(colnames(res$data) %in% res$group)] # prepare data for mirt
    dat0 <- dat0[, unlist(res$items)]
    partialItems <- NULL
    mod <- NULL
    for (lv in res$lvs) {
      partialItems <- append(partialItems,
                             res$items[[lv]][which(res[[lv]]$itemClustering$finalClustering %in% clusters[[lv]])])
      mod <- append(mod, paste0(lv, " = ", paste0(res$items[[lv]], collapse = ",")))
    }
    mod <- paste0(mod, collapse = "\n")

    output <- multipleGroup(data = dat0,
                            model = mod,
                            itemtype = res$settings$dichModel,
                            method = res$settings$estim,
                            group = as.factor(res$data[, res$group]),
                            invariance = c("free_variances", "free_means",
                                           partialItems),
                            SE = TRUE,
                            verbose = FALSE)
  }

  if (!silent) {
    if (res$settings$dichModel == "factor") {      # lavaan
      summary(output)
    } else {                                       # mirt
      cat("mirt model estimates\n\n")
      header <- capture.output(show(output))
      header <- header[grep("Full-info", header):(length(header) - 2)]
      cat(paste(header, collapse = "\n"))
      cat("\n")
      if (res$settings$missings == "none") {
        print(t(round(M2(output), 3)))
      } else {
        cat("Further fit statistics could not be computed due to missing values.")
      }
      cat("\n\nParameter Estimates:\n\n")
      print(coef(output, simplify = TRUE))
    }
  }

  return(output)
}
