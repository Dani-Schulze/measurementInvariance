##
#' @title getModel
#'
#' @description Extract a specific model from global MI testing or from model avaraging.
#'
#' @param res Object generated by \code{\link{testMI}} or \code{\link{modelAveraging}}.
#' @param which Either
#'  \itemize{
#'  \item{String, for MI level in \code{\link{testMI}}. Can be \code{configural}
#' , \code{weak}, \code{strong}, or \code{strict}.}
#'  \item{Numeric, cluster number for desired partial MI model in
#'  \code{\link{modelAveraging}}.}
#' }
#' @param silent Do not print summary output? Defaults to \code{FALSE}.
#'
#' @return Parameters (and model fit for non-Bayesian) of a single unidimensional
#' model of either a specific MI level or a specific partial MI model.
#' Results are directly printed to the console but can
#' be further inspected by functions of lavaan/mirt or blavaan/rstan.
#'
#' @usage res <- getModel(res = NULL,
#'                        which = NULL,
#'                        silent = FALSE)
#'
#'
#' @export


getModel <- function(res,
                     which,
                     silent = FALSE) {
 # from testMI
  if (is.null(res$fittedModels)) {
    if (is.null(res$Factor[[which]])) {
      stop("Model defined by which argument is not present.",
           call. = FALSE)
    }
    if (!silent) {
      if (res$model$dichModel == "factor") {      # lavaan
        lavaan::summary(res$Factor[[which]][[1]], fit.measures = TRUE)
      } else {                                       # mirt
        cat("mirt model estimates\n\n")
        header <- capture.output(show(res$Factor[[which]][[1]]))
        header <- header[grep("Full-info", header):(length(header) - 2)]
        cat(paste(header, collapse = "\n"))
        cat("\n")
        if (res$model$missings == "none") {
          print(t(round(M2(res$Factor[[which]][[1]]), 3)))
        } else {
          cat("Further fit statistics could not be computed due to missing values. (Maydeu-Olivares & Joe, 2006)")
        }
        cat("\n\nParameter Estimates:\n\n")
        print(mirt::coef(res$Factor[[which]][[1]], simplify = TRUE))
      }
    }
    invisible(res$Factor[[which]][[1]]) # return object
  }
 #from modelAveraging
  if (!is.null(res$fittedModels)) {
    if (!silent) {
      if (class(res$fittedModels[[1]]) == "stanfit") {
        post <- rstan::summary(res$fittedModels[[paste0("Cluster=", which)]])
        post <- post$summary[grep("PersPar",
                                  rownames(post$summary),
                                  invert = TRUE), ]
        post <- post[grep("equal",
                          rownames(post),
                          invert = TRUE), ]
        # rename
        rownames(post)[grep("^b", rownames(post))] <- sub("^b", "item_difficulty",
                                                          rownames(post)[grep("^b", rownames(post))])
        rownames(post)[grep("^v", rownames(post))] <- sub("^v", "item_discrimination",
                                                          rownames(post)[grep("^v", rownames(post))])
        rownames(post)[grep("Alpha_free", rownames(post))] <- sub("Alpha_free", "mean_difference",
                                                          rownames(post)[grep("Alpha_free", rownames(post))])
        rownames(post)[grep("Psi_var", rownames(post))] <- sub("Psi_var", "variance_ratio",
                                                                  rownames(post)[grep("Psi_var", rownames(post))])
        post <- post[-nrow(post), ] # drop lp
        print(round(post[, c(1:4, (8:10))], 3))
      }
      if (class(res$fittedModels[[1]]) == "blavaan") {
        summary(res$fittedModels[[paste0("Cluster=", which)]])
      }
    }
  }
  invisible(res$fittedModels[[paste0("Cluster=", which)]])
}
